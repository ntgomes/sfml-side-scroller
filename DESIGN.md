# Design of the SMFL Game Engine
The game engine uses the Pure Component model architecture described in Jason Gregory's _Game Engine Architecture 3rd Edition_, section 15.2. A UML diagram for the structure of the architecture, as well as its accompanying manager and enums, can be seen below.
<img src="https://github.com/ntgomes/sfml-side-scroller/blob/main/ClassDiagram.png" />

The order in which to follow the logic of the object model is:
1. **PureComponent**: the base class that all components in my pure component model would inherit from. Each PureComponent has an integer denoting its unique ID, an integer denoting the ID of the object that it belongs to, and a ComponentType value. ComponentType is an enum, and it was made for the sole purpose of emulating Java’s “instanceof” operator in C++. C++ does not  support the use of “instanceof”, which could differentiate the type of child class given a parent class object, so having an enum denoting what type of PureComponent a given component is was Rthe next best option.
2. **Renderable**: the first actual component. Each Renderable has an SFML ConvexShape, an SFML Color for its ConvexShape, and a RenderType enum. The RenderType enum was made to differentiate between the two different types of renderables: characters and platforms. Character-types are different from platforms in the sense that their starting colors are random, whereas platform-type renderables are passed in a defined color. All Renderables have a position.
3. **Collidable**: this component has a pointer to a Renderable object, and serves to extend the Renderable functionality by handling collisions. Initially, I wanted to have Renderable component also have collision logic, but I realized that for the extent of my game world, not every Renderable would also be Collidable, such as a background. As a final note, each Collidable would have a pointer to another Collidable denoting the object that it is colliding with to make handling collision between renders more efficient.
4. **AutoMovable**: this component would have a direction of movement, the speed of the movement, and an integer timer for the movement. The direction of movement would be given as an enum with  Horizontal and Vertical options. Thus, AutoMovables with Horizontal direction would move horizontally with the given speed, and likewise for Vertical.
5. **ControllerMovable**: this component waits for keyboard input (e.g. ‘A’ and ‘D’) to move the Renderable’s render a set amount of pixels across the screen.
6. **Gravitable**: this components allows for falling. If a ControllerMovable character is not colliding with another character that serves as a platform, then that character should fall. The reason why jumping is not also handled by the ControllerMovable component is the same reason as why Renderable and Collidable are separated into their own thing; not every character that will move left and right does not necessarily need to fall.
7. **Jumpable**: this component handles jumping. The reason why jumping is also not also handled by the ControllerMovable component is the same reason as why Renderable and Collidable are separated into their own thing; not every character that will move left and right will also be able to jump, so I wanted to make sure my object model could handle that.
8. **Warpable**: the components handles warping a collidable to a defined position, as well as handling where a collidable should go when they touch to the left and right boundaries that is key to the functionality of a side-scroller. There are three kinds of WarpType: death zone, left boundary, and right boundary. The death zone serves to warp the character to another spot on the screen when they touch it (like a pit). The left and right boundaries trigger the screen scrolling and move the character to the opposite side of the new screen.
